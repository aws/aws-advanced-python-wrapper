#
# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License").
# You may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


AuroraPgDialect.HasExtensionsTrue=[AuroraPgDialect] has_extensions: True
AuroraPgDialect.HasTopologyTrue=[AuroraPgDialect] has_topology: True

AuroraInitialConnectionStrategyPlugin.RequireDynamicProvider=[AuroraInitialConnectionStrategyPlugin] Dynamic host list provider is required.
AuroraInitialConnectionStrategyPlugin.UnsupportedStrategy=[AuroraInitialConnectionStrategyPlugin] Unsupported host selection strategy '{}'.

AdfsCredentialsProviderFactory.FailedLogin=[AdfsCredentialsProviderFactory] Failed login. Could not obtain SAML Assertion from ADFS SignOn Page POST response: '{}'
AdfsCredentialsProviderFactory.GetSamlAssertionFailed=[AdfsCredentialsProviderFactory] Failed to get SAML Assertion due to exception: '{}'
AdfsCredentialsProviderFactory.SignOnPagePostActionUrl=[AdfsCredentialsProviderFactory] ADFS SignOn Action URL: '{}'
AdfsCredentialsProviderFactory.SignOnPagePostActionRequestFailed=[AdfsCredentialsProviderFactory] ADFS SignOn Page POST action failed with HTTP status '{}', reason phrase '{}', and response '{}'
AdfsCredentialsProviderFactory.SignOnPageUrl=[AdfsCredentialsProviderFactory] ADFS SignOn URL: '{}'

AwsSdk.UnsupportedRegion=[AwsSdk] Unsupported AWS region {}. For supported regions please read https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html

AwsSecretsManagerPlugin.ConnectException=[AwsSecretsManagerPlugin] Error occurred while opening a connection: {}
AwsSecretsManagerPlugin.EndpointOverrideInvalidConnection=[AwsSecretsManagerPlugin] A connection to the provided secrets_manager_endpoint could not be established: "{}".
AwsSecretsManagerPlugin.EndpointOverrideMisconfigured=[AwsSecretsManagerPlugin]  The provided secrets_manager_endpoint is invalid and could not be used to create a URI: "{}".
AwsSecretsManagerPlugin.FailedLogin=[AwsSecretsManagerPlugin] Login failed. Error = {}
AwsSecretsManagerPlugin.FailedToFetchDbCredentials=[AwsSecretsManagerPlugin] Was not able to either fetch or read the database credentials from AWS Secrets Manager. Ensure the correct secrets_manager_secret_id and secrets_manager_region configuration have been provided.
AwsSecretsManagerPlugin.JsonDecodeError=[AwsSecretsManagerPlugin] Error occurred while retrieving credentials from the secrets JSON file. Error = {}
AwsSecretsManagerPlugin.MissingRequiredConfigParameter=[AwsSecretsManagerPlugin] Configuration parameter {} is required.
AwsSecretsManagerPlugin.UnhandledException=[AwsSecretsManagerPlugin] Unhandled exception: {}

AwsWrapperConnection.ConnectionNotOpen=[AwsWrapperConnection] Attempted to establish an initial connection, but the connection returned by the connect call evaluated to None.
AwsWrapperConnection.InitialHostInfoNone=[AwsWrapperConnection] The initial connection host info unexpectedly evaluated to None after initializing the host list provider.

conftest.ExceptionWhileObtainingInstanceIDs=[conftest] An exception was thrown while attempting to obtain the cluster's instance IDs: '{}'

ConnectTimePlugin.ConnectTime=[ConnectTimePlugin] Connected in {} nanos.

ConnectionProvider.UnsupportedHostSelectorStrategy=[ConnectionProvider] Unsupported host selection strategy '{}' specified for this connection provider '{}'. Please visit the documentation for all supported strategies.

ConnectionStringHostListProvider.UnsupportedMethod = [ConnectionStringHostListProvider] ConnectionStringHostListProvider does not support {}.

CustomEndpointMonitor.DetectedChangeInCustomEndpointInfo=[CustomEndpointMonitor] Detected change in custom endpoint info for '{}':\n{}
CustomEndpointMonitor.Exception=[CustomEndpointMonitor] Encountered an exception while monitoring custom endpoint '{}': {}.
CustomEndpointMonitor.Interrupted=[CustomEndpointMonitor] Custom endpoint monitor for '{}' was interrupted.
CustomEndpointMonitor.StartingMonitor=[CustomEndpointMonitor] Starting custom endpoint monitor for '{}'.
CustomEndpointMonitor.StoppedMonitor=[CustomEndpointMonitor] Stopped custom endpoint monitor for '{}'.
CustomEndpointMonitor.StoppingMonitor=[CustomEndpointMonitor] Stopping custom endpoint monitor for '{}'.
CustomEndpointMonitor.UnexpectedNumberOfEndpoints=[CustomEndpointMonitor] Unexpected number of custom endpoints with endpoint identifier '{}' in region '{}'. Expected 1, but found {}. Endpoints:\n{}.

CustomEndpointPlugin.TimedOutWaitingForCustomEndpointInfo=[CustomEndpointPlugin] The custom endpoint plugin timed out after {}ms while waiting for custom endpoint info for host '{}'.
CustomEndpointPlugin.ConnectionRequestToCustomEndpoint=[CustomEndpointPlugin] Detected a connection request to a custom endpoint URL: '{}'.
CustomEndpointPlugin.ErrorParsingEndpointIdentifier=[CustomEndpointPlugin] Unable to parse custom endpoint identifier from URL: '{}'.
CustomEndpointPlugin.InterruptedThread=[CustomEndpointPlugin] The custom endpoint plugin was interrupted while waiting for custom endpoint info for host '{}'.
CustomEndpointPlugin.WaitingForCustomEndpointInfo=[CustomEndpointPlugin] Custom endpoint info for '{}' was not found. Waiting {}ms for the endpoint monitor to fetch info...

DefaultPlugin.EmptyHosts=[DefaultPlugin] The default connection plugin received an empty host list from the plugin service.
DefaultPlugin.UnknownHosts=[DefaultPlugin] A HostInfo with the role of HostRole.UNKNOWN was requested via get_host_info_by_strategy. The requested role must be either HostRole.WRITER or HostRole.READER.

DefaultTelemetryFactory.InvalidMetricsBackend=[DefaultTelemetryFactory] {} is not a valid metrics backend. Available options: OTLP, NONE.
DefaultTelemetryFactory.InvalidTracingBackend=[DefaultTelemetryFactory] {} is not a valid tracing backend. Available options: OTLP, XRAY, NONE.
DefaultTelemetryFactory.NoMetricsBackendProvided=[DefaultTelemetryFactory] No telemetry metrics backend provided. Available options: OTLP, XRAY, NONE.
DefaultTelemetryFactory.NoTracingBackendProvided=[DefaultTelemetryFactory] No telemetry tracing backend provided. Available options: OTLP, XRAY, NONE.

DialectCode.InvalidStringValue=[DialectCode] '{}' is not a valid DialectCode value. If you are using the 'wrapper_dialect' connection property, please ensure you set it to one of the following: pg, rds-pg, aurora-pg, mysql, rds-mysql, aurora-mysql, or custom.

DatabaseDialectManager.CurrentDialectCanUpdate=[DatabaseDialectManager] Current dialect: {}, {}, can_update: {}
DatabaseDialectManager.QueryForDialectTimeout=[DatabaseDialectManager] The timeout limit was reached while querying for the current database dialect.
DatabaseDialectManager.UnknownDialect=[DatabaseDialectManager] The database dialect could not be identified. Please use the 'wrapper_dialect' configuration parameter to configure it.
DatabaseDialectManager.UnknownDialectCode=[DatabaseDialectManager] Unknown dialect code: '{}'.

DeveloperPlugin.MethodNameEmpty=[DeveloperPlugin] method_name should not be empty.
DeveloperPlugin.RaisedExceptionWhileExecuting=[DeveloperPlugin] Raised an exception '{}' while executing '{}'
DeveloperPlugin.RaisedExceptionOnConnect=[DeveloperPlugin] Raised an exception '{}' while opening a new connection.

DriverConnectionProvider.ConnectingToHost=[DriverConnectionProvider] Connecting to '{}' with properties: '{}'
DriverConnectionProvider.UnsupportedStrategy=[DriverConnectionProvider] DriverConnectionProvider does not support strategy: {}

DriverDialect.ExecuteTimeout=[DriverDialect] The timeout limit was reached while executing '{}'.
DriverDialect.InvalidTargetAttribute=[DriverDialect] [{}] Could not find a valid target connection attribute for the '{}' method
DriverDialect.UnsupportedOperationError=[DriverDialect] target driver '{}' dialect doesn't support '{}'.

DriverDialectManager.CustomDialectNotSupported=[DriverDialectManager] The provided custom target driver dialect is not compatible with the given target connect function and will thus be ignored.
DriverDialectManager.InitializationError=[DriverDialectManager] The driver was unable to initialize the target driver dialect due to a missing module. Please ensure your environment has the target driver '{}' installed.
DriverDialectManager.UnknownDialectCode=[DriverDialectManager] Unknown target driver dialect code: {}.
DriverDialectManager.UseDialect=[DriverDialectManager] Target driver dialect set to: {}, {}.

ExecuteTimePlugin.ExecuteTime=[ExecuteTimePlugin] Executed {} in {} nanos.

FailoverPlugin.Changes=[Failover] Changes: {}
FailoverPlugin.ConnectionChangedError=[Failover] The active SQL connection has changed due to a connection failure. Please re-configure session state if required.
FailoverPlugin.ConnectionToHostFailed=[Failover] Connection to '{}' host '{}' failed.
FailoverPlugin.DetectedException=[Failover] Detected an exception while executing a command: {}
FailoverPlugin.EstablishedConnection=[Failover] Connected to: {}
FailoverPlugin.FailoverDisabled=[Failover] Cluster-aware failover is disabled.
FailoverPlugin.InvalidHost=[Failover] Host is no longer available in the topology: {}
FailoverPlugin.NewWriterNotAllowed=[Failover] The failover process identified the new writer but the host is not in the list of allowed hosts. New writer host: '{}'. Allowed hosts {}
FailoverPlugin.NoOperationsAfterConnectionClosed=[Failover] No operations allowed after connection closed.
FailoverPlugin.ParameterValue=[Failover] {}={}
FailoverPlugin.StartReaderFailover=[Failover] Starting reader failover procedure.
FailoverPlugin.StartWriterFailover=[Failover] Starting writer failover procedure.
FailoverPlugin.TransactionResolutionUnknownError=[Failover] Transaction resolution unknown. Please re-configure session state if required and try restarting the transaction.
FailoverPlugin.UnableToConnectToReader=[Failover] Unable to establish SQL connection to the reader instance.
FailoverPlugin.UnableToConnectToWriter=[Failover] Unable to establish SQL connection to the writer instance.

FastestResponseStrategyPlugin.RandomHostSelected=[FastestResponseStrategyPlugin] Fastest host not calculated. Random host selected instead.
FastestResponseStrategyPlugin.UnsupportedHostSelectorStrategy=[FastestResponseStrategyPlugin] Unsupported host selector strategy: '{}'. To use the fastest response strategy plugin, please ensure the property reader_host_selector_strategy is set to fastest_response.

FederatedAuthPlugin.UnhandledException=[FederatedAuthPlugin] Unhandled exception: '{}'
FederatedAuthPlugin.UseCachedToken=[FederatedAuthPlugin] Used cached authentication token = {}

OktaAuthPlugin.UnhandledException=[OktaAuthPlugin] Unhandled exception: '{}'
OktaAuthPlugin.UseCachedToken=[OktaAuthPlugin] Used cached authentication token = {}

OktaCredentialsProviderFactory.SamlAssertionUrl=[OktaCredentialsProviderFactory] Retrieving SAML assertion from URL: '{}'

SamlUtils.InvalidHttpsUrl=[SamlUtils] Invalid HTTPS URL: '{}'
SamlUtils.RequestFailed=[SamlUtils] Request Failed with HTTP status '{}', reason phrase '{}', and response '{}'

FederatedAuthPluginFactory.UnsupportedIdp=[FederatedAuthPluginFactory] Unsupported Identity Provider '{}'. Please visit to the documentation for supported Identity Providers.

HostAvailabilityStrategy.InvalidInitialBackoffTime=[HostAvailabilityStrategy] Invalid value of {} for configuration parameter `host_availability_strategy_initial_backoff_time`. It must be an integer greater than 1.
HostAvailabilityStrategy.InvalidMaxRetries=[HostAvailabilityStrategy] Invalid value of {} for configuration parameter `host_availability_strategy_max_retries`. It must be an integer greater than 1.

HostMonitoringPlugin.ActivatedMonitoring=[HostMonitoringPlugin] Executing method '{}', monitoring is activated.
HostMonitoringPlugin.ClusterEndpointHostInfo=[HostMonitoringPlugin] The HostInfo to monitor is associated with a cluster endpoint. The plugin will attempt to identify the connected database instance.
HostMonitoringPlugin.ErrorIdentifyingConnection=[HostMonitoringPlugin] An error occurred while identifying the connection database instance: '{}'.
HostMonitoringPlugin.MonitoringDeactivated=[HostMonitoringPlugin] Monitoring deactivated for method '{}'.
HostMonitoringPlugin.ConnectionNone=[HostMonitoringPlugin] Attempted to execute method '{}' but the current connection is None.
HostMonitoringPlugin.HostInfoNone=[HostMonitoringPlugin] Could not find HostInfo to monitor for the current connection.
HostMonitoringPlugin.HostInfoNoneForMethod=[HostMonitoringPlugin] Attempted to execute method '{}' but the current host info is None.
HostMonitoringPlugin.ConfigurationNotSupported=[HostMonitoringPlugin] Aborting connections from a separate thread is not supported for the detected driver dialect: '{}'. The EFM plugin requires this feature to be supported.
HostMonitoringPlugin.UnableToIdentifyConnection=[HostMonitoringPlugin] Unable to identify the connected database instance: '{}', please ensure the correct host list provider is specified. The host list provider in use is: '{}'.
HostMonitoringPlugin.UnavailableHost=[HostMonitoringPlugin] Host '{}' is unavailable.

HostSelector.NoEligibleHost=[HostSelector] No Eligible Hosts Found.
HostSelector.NoHostsMatchingRole=[HostSelector] No hosts were found matching the requested role: '{}'.

IamAuthPlugin.ConnectException=[IamAuthPlugin] Error occurred while opening a connection: {}
IamAuthPlugin.InvalidPort=[IamAuthPlugin] Port number: {} is not valid. Port number should be greater than zero. Falling back to default port.
IamAuthPlugin.NoValidPort=[IamAuthPlugin] Unable to determine a valid port.
IamAuthPlugin.UnhandledException=[IamAuthPlugin] Unhandled exception: {}
IamAuthPlugin.UseCachedIamToken=[IamAuthPlugin] Used cached IAM token = {}
IamAuthPlugin.InvalidHost=[IamAuthPlugin] Invalid IAM host {}. The IAM host must be a valid RDS or Aurora endpoint.
IamAuthPlugin.IsNoneOrEmpty=[IamAuthPlugin] Property "{}" is None or empty.
IamAuthUtils.GeneratedNewAuthToken=Generated new authentication token = {}

LimitlessPlugin.FailedToConnectToHost=[LimitlessPlugin] Failed to connect to host {}.
LimitlessPlugin.UnsupportedDialectOrDatabase=[LimitlessPlugin] Unsupported dialect '{}' encountered. Please ensure the connection parameters are correct, and refer to the documentation to ensure that the connecting database is compatible with the Limitless Connection Plugin.

LimitlessQueryHelper.UnsupportedDialectOrDatabase=[LimitlessQueryHelper] Unsupported dialect '{}' encountered. Please ensure JDBC connection parameters are correct, and refer to the documentation to ensure that the connecting database is compatible with the Limitless Connection Plugin.

LimitlessRouterMonitor.errorDuringMonitoringStop=[LimitlessRouterMonitor] Stopping monitoring after unhandled error was thrown in Limitless Router Monitoring thread for node {}. Error: {}
LimitlessRouterMonitor.InterruptedErrorDuringMonitoring=[LimitlessRouterMonitor] Limitless Router Monitoring thread for node {} was interrupted.
LimitlessRouterMonitor.InvalidQuery=[LimitlessRouterMonitor] Limitless Connection Plugin has encountered an error obtaining Limitless Router endpoints. Please ensure that you are connecting to an Aurora Limitless Database Shard Group Endpoint URL.
LimitlessRouterMonitor.InvalidRouterLoad=[LimitlessRouterMonitor] Invalid load metric value of '{}' from the transaction router query aurora_limitless_router_endpoints() for transaction router '{}'. The load metric value must be a decimal value between 0 and 1. Host weight be assigned a default weight of 1.
LimitlessRouterMonitor.GetNetworkTimeoutError=[LimitlessRouterMonitor] An error occurred while getting the connection network timeout: {}
LimitlessRouterMonitor.OpeningConnection=[LimitlessRouterMonitor] Opening Limitless Router Monitor connection to '{}'.
LimitlessRouterMonitor.OpenedConnection=[LimitlessRouterMonitor] Opened Limitless Router Monitor connection: {}.
LimitlessRouterMonitor.Running=[LimitlessRouterMonitor] Limitless Router Monitor thread running on node {}.
LimitlessRouterMonitor.Stopped=[LimitlessRouterMonitor] Limitless Router Monitor thread stopped on node {}.

LimitlessRouterService.ConnectWithHost=[LimitlessRouterService] Connecting to host {}.
LimitlessRouterService.ErrorClosingMonitor=[LimitlessRouterService] An error occurred while closing Limitless Router Monitor: {}
LimitlessRouterService.ErrorStartingMonitor=[LimitlessRouterService] An error occurred while starting Limitless Router Monitor: {}
LimitlessRouterService.FailedToConnectToHost=[LimitlessRouterService] Failed to connect to host {}.
LimitlessRouterService.FetchedEmptyRouterList=[LimitlessRouterService] Empty router list was fetched.
LimitlessRouterService.GetLimitlessRoutersError=[LimitlessRouterService] error encountered getting Limitless Routers. {}
LimitlessRouterService.IncorrectConfiguration=[LimitlessRouterService] Limitless Connection Plugin is unable to run. Please ensure the connection settings are correct.
LimitlessRouterService.InterruptedSynchronousGetRouter=[LimitlessRouterService] Limitless Router Service thread was interrupted while waiting to fetch Limitless Transaction Routers.
LimitlessRouterService.LimitlessRouterCacheEmpty=[LimitlessRouterService] Limitless Router cache is empty. This is normal during application start up when the cache is not yet populated.
LimitlessRouterService.LockFailedToAcquire=[LimitlessRouterService] Failed to acquire Lock.
LimitlessRouterService.MaxRetriesExceeded=[LimitlessRouterService] Max number of connection retries has been exceeded. Unable to connect to any transaction router.
LimitlessRouterService.NoRoutersAvailable=[LimitlessRouterService] Unable to connect to any transaction router.
LimitlessRouterService.NoRoutersAvailableForRetry=[LimitlessRouterService] No transaction routers available for connection retry. Retrying with original connection.
LimitlessRouterService.UnableToConnectNoRoutersAvailable=[LimitlessRouterService] Unable to connect to original host {}. All transaction routers are unavailable. Please verify connection credentials and network connectivity.
LimitlessRouterService.SelectedHost=[LimitlessRouterService] Host {} has been selected.
LimitlessRouterService.SelectedHostForRetry=[LimitlessRouterService] Host {} has been selected for connection retry.
LimitlessRouterService.SynchronouslyGetLimitlessRouters=[LimitlessRouterService] Fetching Limitless Routers synchronously.
LimitlessRouterService.UsingProvidedConnectUrl=[LimitlessRouterService] Connecting using provided connection URL.

LogUtils.Topology=[LogUtils] Topology {}

Monitor.ContextNone=[Monitor] Parameter 'context' should not evaluate to None.
Monitor.ExceptionInMonitorLoop=[Monitor] Continuing monitoring after an unhandled exception was thrown in the monitoring thread for host '{}'.
Monitor.StoppingMonitorUnhandledException=[Monitor] Stopping thread after an unhandled exception was thrown in the monitoring thread for host '{}'.
Monitor.InterruptedException=[Monitor] Monitoring thread for host '{}' was interrupted.
Monitor.OpenedMonitorConnection=[Monitor] Opened a monitoring connection to '{}'.
Monitor.OpeningMonitorConnection=[Monitor] Opening a monitoring connection to '{}'.

MonitorContext.ExceptionAbortingConnection=[MonitorContext] An exception occurred while attempting to abort the monitored connection: '{}'.
MonitorContext.HostAvailable=[MonitorContext] Host '{}' is *available*.
MonitorContext.HostNotResponding=[MonitorContext] Host '{}' is not *responding* - failure count: '{}'.
MonitorContext.HostUnavailable=[MonitorContext] Host '{}' is *unavailable*.

MonitoringThreadContainer.EmptyHostKeys=[MonitorThreadContainer] The provided host_aliases set was empty.
MonitoringThreadContainer.ErrorGettingMonitor=[MonitorThreadContainer] Unable to find or create monitor for host with aliases '{}'.
MonitoringThreadContainer.SupplierMonitorNone=[MonitorThreadContainer] The monitor supplier passed into get_or_create_monitor returned None.

MonitorService.EmptyAliasSet=[MonitorService] Empty alias set passed for '{}'. The alias set should not be empty.
MonitorService.ErrorPopulatingAliases=[MonitorService] An error occurred while populating aliases: '{}'.

MultiAzHostListProvider.UnableToParseInstanceName=[MultiAzHostListProvider] The MultiAzHostListProvider was unable to parse the instance name from the endpoint returned by the topology query.

HostResponseTimeMonitor.ExceptionDuringMonitoringStop=[HostResponseTimeMonitor] Stopping thread after unhandled exception was thrown in Response time thread for host {}.
HostResponseTimeMonitor.InterruptedExceptionDuringMonitoring=[HostResponseTimeMonitor] Response time thread for host {} was interrupted.
HostResponseTimeMonitor.OpenedConnection=[HostResponseTimeMonitor] Opened Response time connection: {}.
HostResponseTimeMonitor.OpeningConnection=[HostResponseTimeMonitor] Opening a Response time connection to '{}'.
HostResponseTimeMonitor.ResponseTime=[HostResponseTimeMonitor] Response time for '{}': {} ms
HostResponseTimeMonitor.Stopped=[HostResponseTimeMonitor] Stopped Response time thread for host '{}'.

OpenedConnectionTracker.OpenedConnectionsTracked=[OpenedConnectionTracker] Opened Connections Tracked: {}
OpenedConnectionTracker.InvalidatingConnections=[OpenedConnectionTracker] Invalidating opened connections to host: {}
OpenedConnectionTracker.UnableToPopulateOpenedConnectionSet=[OpenedConnectionTracker] The driver is unable to track this opened connection because the instance endpoint is unknown.

OpenTelemetry.InvalidContext="[OpenTelemetry] Can't use this telemetry context to make a copy."

OpenTelemetryContext.TelemetryTraceID="[OpenTelemetryContext] Telemetry '{}' trace ID: {}"

OpenTelemetryFactory.WrongParameterType="[OpenTelemetryFactory] Wrong parameter type: {}"

Plugin.UnsupportedMethod=[Plugin] '{}' is not supported by this plugin.

PluginManager.ConfigurationProfileNotFound=PluginManager] Configuration profile '{}' not found.
PluginManager.InvalidPlugin=[PluginManager] Invalid plugin requested: '{}'.
PluginManager.MethodInvokedAgainstOldConnection = [PluginManager] The internal connection has changed since '{}' was created. This is likely due to failover or read-write splitting functionality. To ensure you are using the updated connection, please re-create Cursor objects after failover and/or setting readonly.
PluginManager.PipelineNone=[PluginManager] A pipeline was requested but the created pipeline evaluated to None.
PluginManager.ResortedPlugins=[PluginManager] Plugins order has been rearranged. The following order is in effect: {}.

PluginServiceImpl.FailedToRetrieveHostPort=[PluginServiceImpl] Could not retrieve Host:Port for connection. {}
PluginServiceImpl.FillAliasesTimeout=[PluginServiceImpl] The timeout limit was reached while querying for the current host's alias.
PluginServiceImpl.GetHostRoleConnectionNone=[PluginServiceImpl] Attempted to evaluate the host role of the given connection, but could not find a non-None connection to evaluate.
PluginServiceImpl.IncorrectStatusType=[PluginServiceImpl] Received an unexpected type from the status cache. An object of type {} was requested, but the object at key '{}' had a type of {}. The retrieved object was: {}.
PluginServiceImpl.NonEmptyAliases=[PluginServiceImpl] fill_aliases called when HostInfo already contains the following aliases: {}.
PluginServiceImpl.UnableToUpdateTransactionStatus=[PluginServiceImpl] Unable to update transaction status, current connection is None.
PluginServiceImpl.UpdateDialectConnectionNone=[PluginServiceImpl] The plugin service attempted to update the current dialect but could not identify a connection to use.
PluginServiceImpl.UnsupportedStrategy=[PluginServiceImpl] The driver does not support the requested host selection strategy: {}

PropertiesUtils.ErrorParsingConnectionString=[PropertiesUtils] An error occurred while parsing the connection string: '{}'. Please ensure the format of your connection string is valid.
PropertiesUtils.InvalidPgSchemeUrl=[PropertiesUtils] PropertiesUtils.parse_pg_scheme_url was called, but the passed in string did not begin with 'postgresql://' or 'postgres://'. Detected connection string: '{}'.
PropertiesUtils.MultipleHostsNotSupported=[PropertiesUtils] Connection strings containing multiple hosts are not supported by the wrapper driver. If you are using an Aurora database, please specify only the initial instance that you would like to connect to. The cluster topology will be automatically discovered. Detected connection string: '{}'
PropertiesUtils.NoHostDefined=[PropertiesUtils] PropertiesUtils.get_url was called but no host was defined in the properties. Please ensure you pass in a 'host' parameter when connecting.

RdsHostListProvider.ClusterInstanceHostPatternNotSupportedForRDSCustom=[RdsHostListProvider] An RDS Custom url can't be used as the 'cluster_instance_host_pattern' configuration setting.
RdsHostListProvider.ClusterInstanceHostPatternNotSupportedForRDSProxy=[RdsHostListProvider] An RDS Proxy url can't be used as the 'cluster_instance_host_pattern' configuration setting.
RdsHostListProvider.ClusterInstanceHostPatternRequired=[RdsHostListProvider] The 'cluster_instance_host_pattern' configuration property is required when an IP address or custom domain is used to connect to a cluster that provides topology information. If you would instead like to connect without failover functionality, set the 'enable_cluster_aware_failover' configuration property to false.
RdsHostListProvider.ErrorGettingHostRole=[RdsHostListProvider] An error occurred while obtaining the connected host's role. This could occur if the connection is broken or if you are not connected to an Aurora database.
RdsHostListProvider.ErrorGettingNetworkTimeout=[RdsHostListProvider] An error occurred while getting the connection network timeout: {}
RdsHostListProvider.ErrorIdentifyConnection=[RdsHostListProvider] An error occurred while obtaining the connection's host ID.
RdsHostListProvider.GetHostRoleTimeout=[RdsHostListProvider] The timeout limit was reached while querying for the current host's role.
RdsHostListProvider.IdentifyConnectionTimeout=[RdsHostListProvider] The timeout limit was reached while querying for the current host's ID.
RdsHostListProvider.InvalidDialect=[RdsHostListProvider] RdsHostListProvider was instantiated with a non-Aurora database dialect. The current database dialect is '{}'.
RdsHostListProvider.InvalidPattern=[RdsHostListProvider] Invalid value for the 'cluster_instance_host_pattern' configuration setting - the host pattern must contain a '?' character as a placeholder for the DB instance identifiers of the instances in the cluster.
RdsHostListProvider.InvalidQuery=[RdsHostListProvider] Error obtaining host list. Provided database might not be an Aurora Db cluster
RdsHostListProvider.InvalidTopology=[RdsHostListProvider] The topology query returned an invalid topology - no writer instance detected.
RdsHostListProvider.ParsedListEmpty=[RdsHostListProvider] Can't parse connection string: '{}'
RdsHostListProvider.SuggestedClusterId=[RdsHostListProvider] ClusterId '{}' is suggested for url '{}'.
RdsHostListProvider.QueryForTopologyError=[RdsHostListProvider] An error occurred while executing a topology query.
RdsHostListProvider.QueryForTopologyTimeout=[RdsHostListProvider] The timeout limit was reached while querying for the database topology.
RdsHostListProvider.UninitializedClusterInstanceTemplate=[RdsHostListProvider] The driver was unable to build a topology object because the cluster instance template was never initialized.
RdsHostListProvider.UninitializedInitialHostInfo=[RdsHostListProvider] The driver was unable to build a topology object because the initial host info was never initialized.

RdsPgDialect.RdsToolsAuroraUtils=[RdsPgDialect] rds_tools: {}, aurora_utils: {}

RdsTestUtility.ClusterMemberNotFound=[RdsTestUtility] Cannot find cluster member whose db instance identifier is '{}'.
RdsTestUtility.CreateDBInstanceFailed=[RdsTestUtility] Could not create database instance '{}'.
RdsTestUtility.FailoverClusterFailed=[RdsTestUtility] Failed to request a cluster failover for cluster '{}'.
RdsTestUtility.FailoverRequestNotSuccessful=[RdsTestUtility] Failover cluster request was not successful.
RdsTestUtility.FailoverToTargetNotSupported=[RdsTestUtility] Failover to target instance '{}' was requested, but failover to a target is not supported for {} deployments.
RdsTestUtility.InstanceDescriptionTimeout=[RdsTestUtility] Instance description timeout for {}. The instance did not reach status '{}' within {} minutes.
RdsTestUtility.InvalidDatabaseEngine=[RdsTestUtility] The detected database engine is not valid: {}
RdsTestUtility.MethodNotSupportedForDeployment=[RdsTestUtility] Method '{}' is not supported for the current database engine deployment: '{}'
RdsTestUtility.WriterInstanceNotFound=[RdsTestUtility] Cannot find writer instance for cluster '{}'.

RdsUtils.UnsupportedHostname=[RdsUtils] Unsupported AWS hostname {}. Amazon domain name in format *.AWS-Region.rds.amazonaws.com or *.rds.AWS-Region.amazonaws.com.cn is expected.

ReaderFailoverHandler.AttemptingReaderConnection=[ReaderFailoverHandler] Trying to connect to reader: '{}', with properties '{}'
ReaderFailoverHandler.FailedReaderConnection=[ReaderFailoverHandler] Failed to connect to reader: '{}'
ReaderFailoverHandler.InvalidTopology=[ReaderFailoverHandler] '{}' was called with an invalid (None or empty) topology.
ReaderFailoverHandler.SuccessfulReaderConnection=[ReaderFailoverHandler] Connected to reader: '{}'

ReadWriteSplittingPlugin.ClosingInternalConnections=[ReadWriteSplittingPlugin] Closing all internal connections except for the current one.
ReadWriteSplittingPlugin.EmptyHostList=[ReadWriteSplittingPlugin] Host list is empty.
ReadWriteSplittingPlugin.ErrorSwitchingToCachedReader=[ReadWriteSplittingPlugin] An error occurred while trying to switch to a cached reader connection: '{}'. The driver will attempt to establish a new reader connection.
ReadWriteSplittingPlugin.ErrorSwitchingToReader=[ReadWriteSplittingPlugin] An error occurred while trying to switch to a reader connection.
ReadWriteSplittingPlugin.ErrorSwitchingToWriter=[ReadWriteSplittingPlugin] An error occurred while trying to switch to a writer connection.
ReadWriteSplittingPlugin.ErrorVerifyingInitialHostSpecRole=[ReadWriteSplittingPlugin] An error occurred while obtaining the connected host's role. This could occur if the connection is broken or if you are not connected to an Aurora database.
ReadWriteSplittingPlugin.ExceptionWhileExecutingCommand=[ReadWriteSplittingPlugin] Detected an exception while executing a command: '{}'
ReadWriteSplittingPlugin.ExecutingAgainstOldConnection=[ReadWriteSplittingPlugin] Executing method against old connection: '{}'
ReadWriteSplittingPlugin.FailedToConnectToReader=[ReadWriteSplittingPlugin] Failed to connect to reader host: '{}'
ReadWriteSplittingPlugin.FailoverExceptionWhileExecutingCommand=[ReadWriteSplittingPlugin] Detected a failover exception while executing a command: '{}'
ReadWriteSplittingPlugin.FallbackToWriter=[ReadWriteSplittingPlugin] Failed to switch to a reader; the current writer will be used as a fallback: '{}'
ReadWriteSplittingPlugin.NoReadersAvailable=[ReadWriteSplittingPlugin] The plugin was unable to establish a reader connection to any reader instance.
ReadWriteSplittingPlugin.NoReadersFound=[ReadWriteSplittingPlugin] A reader instance was requested via set_read_only, but there are no readers in the host list. The current writer will be used as a fallback: '{}'
ReadWriteSplittingPlugin.NoWriterFound=[ReadWriteSplittingPlugin] No writer was found in the current host list. This may occur if the writer is not in the list of allowed hosts.
ReadWriteSplittingPlugin.SetReaderConnection=[ReadWriteSplittingPlugin] Reader connection set to '{}'
ReadWriteSplittingPlugin.SetReadOnlyFalseInTransaction=[ReadWriteSplittingPlugin] set_read_only(false) was called on a read-only connection inside a transaction. Please complete the transaction before calling set_read_only(false).
ReadWriteSplittingPlugin.SetReadOnlyOnClosedConnection=[ReadWriteSplittingPlugin] set_read_only cannot be called on a closed connection.
ReadWriteSplittingPlugin.SettingCurrentConnection=[ReadWriteSplittingPlugin] Setting the current connection to '{}'
ReadWriteSplittingPlugin.SetWriterConnection=[ReadWriteSplittingPlugin] Writer connection set to '{}'
ReadWriteSplittingPlugin.SuccessfullyConnectedToReader=[ReadWriteSplittingPlugin] Successfully connected to a new reader host: '{}'
ReadWriteSplittingPlugin.SwitchedFromReaderToWriter=[ReadWriteSplittingPlugin] Switched from a reader to a writer host. New writer host: '{}'
ReadWriteSplittingPlugin.SwitchedFromWriterToReader=[ReadWriteSplittingPlugin] Switched from a writer to a reader host. New reader host: '{}'
ReadWriteSplittingPlugin.UnavailableHostInfo=[ReadWriteSplittingPlugin] Current Host Info could not be found in plugin service.
ReadWriteSplittingPlugin.UnsupportedHostInfoSelectorStrategy=[ReadWriteSplittingPlugin] Unsupported host selection strategy '{}' specified in plugin configuration parameter 'reader_host_selector_strategy'. Please visit the Read/Write Splitting Plugin documentation for all supported strategies.

RoundRobinHostSelector.ClusterInfoNone=[RoundRobinHostSelector] The round robin cluster information cache should have an entry for the current cluster, but no entry was found.
RoundRobinHostSelector.RoundRobinInvalidDefaultWeight=[RoundRobinHostSelector] The provided default weight value is not valid. Weight values must be an integer greater than or equal to 1.
RoundRobinHostSelector.RoundRobinInvalidHostWeightPairs= [RoundRobinHostSelector] The provided host weight pairs have not been configured correctly. Please ensure the provided host weight pairs is a comma separated list of pairs, each pair in the format of <host>:<weight>. Weight values must be an integer greater than or equal to the default weight value of 1. Weight pair: '{}'

WeightedRandomHostSelector.WeightedRandomInvalidHostWeightPairs= [WeightedRandomHostSelector] The provided host weight pairs have not been configured correctly. Please ensure the provided host weight pairs is a comma separated list of pairs, each pair in the format of <host>:<weight>. Weight values must be an integer greater than or equal to the default weight value of 1. Weight pair: '{}'
WeightedRandomHostSelector.WeightedRandomInvalidDefaultWeight=[WeightedRandomHostSelector] The provided default weight value is not valid. Weight values must be an integer greater than or equal to 1.

SlidingExpirationCache.CleaningUp=[SlidingExpirationCache] Cleaning up...

SqlAlchemyPooledConnectionProvider.PoolNone=[SqlAlchemyPooledConnectionProvider] Attempted to find or create a pool for '{}' but the result of the attempt evaluated to None.
SqlAlchemyPooledConnectionProvider.UnableToCreateDefaultKey=[SqlAlchemyPooledConnectionProvider] Unable to create a default key for internal connection pools. By default, the user parameter is used, but the given user evaluated to None or the empty string (""). Please ensure you have passed a valid user in the connection properties.

SqlAlchemyDriverDialect.SetValueOnNoneConnection=[SqlAlchemyDriverDialect] Attempted to set the '{}' value on a pooled connection, but no underlying driver connection was found. This can happen if the pooled connection has previously been closed.

StaleDnsHelper.ClusterEndpointDns=[StaleDnsPlugin] Cluster endpoint {} resolves to {}.
StaleDnsHelper.CurrentWriterNotAllowed=[StaleDnsPlugin] The current writer is not in the list of allowed hosts. Current host: '{}'. Allowed hosts: {}
StaleDnsHelper.Reset=[StaleDnsPlugin] Reset stored writer host.
StaleDnsHelper.StaleDnsDetected=[StaleDnsPlugin] Stale DNS data detected. Opening a connection to '{}'.
StaleDnsHelper.WriterHostSpec=[StaleDnsPlugin] Writer host: {}
StaleDnsHelper.WriterInetAddress=[StaleDnsPlugin] Writer host address: {}

StaleDnsPlugin.RequireDynamicProvider=[StaleDnsPlugin] A dynamic host list provider is required for the stale DNS plugin, but the detected host list was a static provider.

Testing.CantParse=[Testing] Can't parse {}.
Testing.DisabledConnectivity=[Testing] Disabled connectivity to {}.
Testing.EnabledConnectivity=[Testing] Enabled connectivity to {}.
Testing.EnvVarRequired=[Testing] Environment variable {} is required.
Testing.FunctionNotImplementedForDriver=[Testing] Function '{}' has no implementation for the passed in driver: '{}'.
Testing.FinishedFailover=[Testing] Finished failover from {} in {}ms.
Testing.InstanceNotFound=[Testing] Instance {} not found.
Testing.OpenConnectionFailed=[Testing] Open connection failed with exception: {}.
Testing.ProxyNotFound=[Testing] Proxy for {} is not found.
Testing.RequiredTestDriver=[Testing] testDriver is required.
Testing._get_multi_az_instance_ids=[Testing] Get topology: {}.
Testing._get_multi_az_instance_ids_connecting=[Testing] Connecting to {}.

UnknownDialect.AbortConnection=[UnknownDialect] abort_connection was called, but the database dialect is unknown. A valid database dialect must be detected in order to abort a connection.

Wrapper.ConnectMethod=[Wrapper] Target driver should be a target driver's connect() method/function.
Wrapper.RequiredTargetDriver=[Wrapper] Target driver is required.
Wrapper.UnsupportedAttribute=[Wrapper] Target driver does not have the attribute: '{}'
Wrapper.Properties=[Wrapper] "Connection Properties: "

WriterFailoverHandler.AlreadyWriter=[WriterFailoverHandler] Current reader connection is actually a new writer connection.
WriterFailoverHandler.CurrentTopologyNone=[WriterFailoverHandler] Current topology cannot be None.
WriterFailoverHandler.FailedToConnectToWriterInstance=[WriterFailoverHandler] Failed to connect to the writer instance.
WriterFailoverHandler.FailoverCalledWithInvalidTopology=[WriterFailoverHandler] Failover was called with an invalid (None or empty) topology.
WriterFailoverHandler.StandaloneHost=[WriterFailoverHandler] [TaskB] Host {} is not yet connected to a cluster. The cluster is still being reconfigured.
WriterFailoverHandler.SuccessfulConnectionInvalidTopology=[WriterFailoverHandler] {} successfully established a connection but doesn't contain a valid topology.
WriterFailoverHandler.SuccessfullyConnectedToNewWriterInstance=[WriterFailoverHandler] Successfully connected to the new writer instance: {}
WriterFailoverHandler.SuccessfullyReconnectedToWriterInstance=[WriterFailoverHandler] Successfully re-connected to the current writer instance: {}
WriterFailoverHandler.TaskAAttemptReconnectToWriterInstance=[WriterFailoverHandler] [TaskA] Attempting to re-connect to the current writer instance: {}, with properties {}
WriterFailoverHandler.TaskAEncounteredException=[WriterFailoverHandler] [TaskA] encountered an exception: {}
WriterFailoverHandler.TaskAFinished=[WriterFailoverHandler] [TaskA] Finished
WriterFailoverHandler.TaskBAttemptConnectionToNewWriter=[WriterFailoverHandler] [TaskB] Trying to connect to a new writer: {}
WriterFailoverHandler.TaskBAttemptConnectionToNewWriterInstance=[WriterFailoverHandler] [TaskB] Attempting to connect to a new writer instance, with properties: {}
WriterFailoverHandler.TaskBConnectedToReader=[WriterFailoverHandler] [TaskB] Connected to reader: {}
WriterFailoverHandler.TaskBEncounteredException=[WriterFailoverHandler] [TaskB] encountered an exception: {}
WriterFailoverHandler.TaskBFailedToConnectToAnyReader=[WriterFailoverHandler] [TaskB] Failed to connect to any reader.
WriterFailoverHandler.TaskBFinished=[WriterFailoverHandler] [TaskB] Finished

XRayTelemetryContext.TraceID="[XRayTelemetryContext] Telemetry '{}' trace ID: {}"

XRayTelemetryFactory.MetricsNotSupported="[XRayTelemetryFactory] XRay doesn't support metrics."
XRayTelemetryFactory.WrongParameterType="[XRayTelemetryFactory] Wrong parameter type: {}"
